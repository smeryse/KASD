# Бинарная куча, Очередь с приоритетом, Пирамидальная сортировка

## Структура данных
Данные + операции = **АТД (Абстрактный Тип Данных)**

**Структура данных** - конкретная реализация абстрактного типа данных в памяти машины. В случае со структурами данных время замеряется для каждой операции. 

Не существует идеальной структуры данных, где все операции выполняются за $O(1)$. 

## Очередь с приоритетом
**Мультимножество** - это такое множество, в котором элементы могут повторятся. В таком множестве нас интересует не только какие элементы множества у нас есть, но и сколько раз они повторяются. 

Элементы должны быть сравнимы между собой (должна существовать операция порядка - компаратор). 

Поддерживает 3 операции:
``` python
1. insert (x)  // A = A u {x}
2. got_min()
3. remove_min() // A = A \ {minA}
   ```

A - массив, а - множество
#### Самая нативная реализация
$a *$ ⬜⬜⬜⬜⬜⬜⬜

```python
insert(x):
	a.append(x)

get_min(): // O(n)
	min = a[0]
	for i in range(1, len(a)):
		min = min(min, a[i])
	return min
	
remove_min(a): // O(n) -  разобраться
	min, j = a[0], 0
	for i in range(1, n - 1):
		if a[i] < min:
			min = a[i]
			j = i
	a[j], a[n-1] =  a[n-1], a[j]
	a.pop()
	return a
```

### 2я реализация
```python

```


### 3я реализация (Бинарная куча)
Бинарная куча - это структура данных, реализующая очередь с приоритетом. Она представляет собой **полное бинарное дерево**. (все уровни заполнены, кроме, возможно, последнего, который заполняется слева направо), для которого выполняется **основное свойство кучи:** 
1. **Свойство кучи (min-beap).** Значение в каждом узле меньше или равно значениям в его дочерних узлах. 
2. Следствие. В корне дерева находится минимальный элемент.
3. Существует также max-heap, где значение в узле больше или равно значениям в потомках.
Ключевая идея: вместо хранения дерева в виде связной структуры с узлами мы будем хранить его **в массиве**. Это эффективно с точки зрения памяти и скорости. 

Схема хранения:
1. Корень дерева хранится в ячейке a[0].
2. Для узла с индексом i: **левый потомок** имеет индекс `left(i) = 2*i +1`, **правый потомок** имеет индекс `right(i) = 2*i + 2`, а **родитель** вычисляется по формуле `parent(i) = (i - 1) // 2`. 
.....==пропущен кусок==

Процесс повторяется до тех пор, пока элемент не станет больше или равен родителю либо не достигнет корня.

```python
def heap_insert(a, x):
	"""Добавляем элемент в кучу."""
	a.append(x) # Добавляем элемент в конец
	sift_up(a, len(a) - 1) # Просеиваем вверх


def sift_up(a, idx):
	"""Поднимает элемент с индексом idx вверх, пока не восстановится куча"""
	while idx > 0:
		parent_idx = (idx - 1) // 2
		if a[idx] < a[parent_idx]:
			# Нарущаем порядок, меняем местами
			a[idx], a[parent_idx] = a[parent_idx], a[idx]
			idx = parent_idx
		else:
			# Порядок восстановлен
			break
	return a
```

## Пирамидальная сортировка