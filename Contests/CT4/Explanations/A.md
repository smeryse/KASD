# Дерево отрезков

Сначала про идею, на которой всё держится. Здесь реализовано дерево отрезков для сумм: структура данных, которая хранит массив чисел и умеет быстро выполнять две операции — изменить значение в одной позиции и узнать сумму на отрезке. Ключевая мысль в том, что мы заранее поддерживаем суммы на больших кусках массива (отрезках), а при изменении одного элемента пересчитываем только те суммы, которые действительно зависят от этого элемента. В этой реализации дерево хранится не как классические узлы с ссылками, а как плотный массив, где родитель и дети вычисляются по индексам.

Первый логический блок — ввод и разбор входных данных в Solve. Этот блок решает задачу “прочитать размер массива и количество операций, затем прочитать исходные значения, затем построчно обработать команды”. Он нужен, потому что сегментное дерево само по себе не знает, какие операции выполняются — оно предоставляет методы Update и Query, а Solve превращает текстовый ввод в вызовы этих методов. Взаимодействие здесь такое: Solve считывает n и m, затем считывает массив values, затем создаёт SegmentTree(values), после чего m раз читает очередную команду и маршрутизирует её либо в st.Update, либо в st.Query с выводом результата. Важно понимать договорённость в комментарии: запрос суммы сделан на полуинтервале [l, r), то есть l включается, а r не включается. Поэтому Query принимает именно l и r как границы полуинтервала.

Второй логический блок внутри Solve — построение массива values. Он решает задачу “преобразовать строку со значениями в массив long[]”. Он нужен потому, что дерево строится от исходного массива и ожидает уже числовые данные. Взаимодействие простое: values передаётся в конструктор SegmentTree, где из него строится внутреннее представление дерева.

Третий логический блок — цикл обработки операций в Solve. Этот блок решает задачу “для каждой из m строк понять, что за операция, и выполнить её”. Он нужен, потому что набор операций может смешиваться: где-то обновление элемента, где-то запрос суммы, и их порядок произвольный. Взаимодействие с деревом здесь прямое: при type == 1 вызывается Update(i, v), то есть элемент массива по индексу i заменяется на v. В противном случае читаются l и r, вызывается Query(l, r), и сумма выводится в консоль. То, что используется именно замена значения, а не “прибавить”, видно по тому, что tree[pos] просто присваивается value.

Теперь перейдём к самому SegmentTree — это центральная часть. Его задача — хранить агрегированную информацию (суммы) так, чтобы обновления и запросы работали эффективно и независимо от того, сколько операций будет потом. Почему он нужен: если каждый раз считать сумму на отрезке “в лоб”, пришлось бы пробегать элементы от l до r-1, а дерево позволяет поддерживать структуру сумм и отвечать быстрее. Как он взаимодействует с остальным кодом: извне видны только конструктор, Update и Query. Solve ничего не знает о внутренней форме хранения — это важный принцип инкапсуляции: внешний код задаёт “что нужно” (изменить/узнать сумму), а дерево решает “как именно”.

Блок построения дерева в конструкторе SegmentTree отвечает за создание внутреннего массива tree и заполнение его так, чтобы в каждой вершине лежала сумма соответствующего отрезка. Здесь используются две идеи. Первая — “выравнивание до степени двойки”: переменная size подбирается как минимальная степень двойки, не меньше длины исходного массива. Это нужно, чтобы дерево было полным по уровням и чтобы индексы детей/родителей работали без сложных вычислений: листья лежат компактно и одинаково “разложены”. Вторая — хранение дерева в одном массиве. Массив tree имеет длину 2*size. Условно, индексы от size до 2*size-1 — это листья, то есть отдельные элементы. Индексы от 1 до size-1 — внутренние узлы, которые хранят суммы детей. Сначала конструктор кладёт исходные значения в листья: tree[size + i] = values[i]. Потом, двигаясь снизу вверх, строит суммы: tree[i] = tree[2*i] + tree[2*i + 1]. Именно поэтому цикл идёт от size-1 к 1: чтобы к моменту вычисления родителя суммы детей уже были готовы. Взаимодействие с дальнейшими операциями такое: после конструктора дерево готово отвечать на запросы и корректно пересчитываться при изменениях.

Блок Update решает задачу точечного изменения: “в массиве на позиции index теперь лежит value”. Почему он нужен: это один из двух типов операций, и дерево должно уметь отражать изменения, иначе запросы сумм начнут выдавать старые значения. Как он работает с другими частями: Update меняет один лист, соответствующий элементу, а затем обновляет все узлы на пути от этого листа к корню, потому что только эти суммы зависят от изменённого элемента. Технически это выглядит так: вычисляется позиция листа pos = size + index, туда записывается новое значение, затем pos сдвигается вправо на 1 (то есть берётся родитель), и в цикле каждый раз пересчитывается сумма из двух детей. Переход pos >>= 1 — это подъём на уровень выше. Взаимодействие тут очень прямое: после Update состояние tree снова соответствует массиву значений, и Query начнёт учитывать новое число.

Блок Query решает задачу “узнать сумму на полуинтервале [l, r)”. Почему он нужен: это второй тип операций. Как он взаимодействует с деревом: Query читает уже готовые суммы узлов tree и собирает ответ из нескольких непересекающихся кусочков, которые в сумме покрывают [l, r). Здесь важна идея, которую стоит проговорить до деталей реализации: любой отрезок можно представить как объединение небольшого числа “канонических” отрезков дерева — то есть отрезков, которые соответствуют вершинам дерева и полностью лежат внутри запроса. Тогда вместо суммирования отдельных элементов мы просто складываем значения этих вершин.

В реализации это делается итеративным “двухуказательным” обходом по листьям. Сначала границы переносятся в систему индексов дерева: left = l + size и right = r + size. Теперь left и right указывают на листья, соответствующие границам диапазона. Далее, пока left < right, мы смотрим, можно ли прямо сейчас “забрать” целый сегмент из левой или правой стороны. Если left — правый ребёнок (это определяется тем, что индекс нечётный: (left & 1) == 1), то сегмент, который он представляет, целиком лежит внутри оставшейся части запроса, поэтому мы добавляем tree[left] к ответу и сдвигаем left на следующий индекс (left++). Аналогично справа: если right — правый ребёнок, то перед тем как подняться, можно забрать сегмент его левого соседа, поэтому делается --right и прибавляется tree[right]. После того как возможные “краевые” сегменты забраны, обе границы поднимаются на уровень выше: left >>= 1, right >>= 1. Так мы постепенно укрупняем рассматриваемые куски, пока диапазон не схлопнется. В итоге res становится суммой всех выбранных канонических сегментов, а значит и суммой на [l, r). Это взаимодействует с Update через общий массив tree: Query доверяет тому, что tree в каждой вершине хранит актуальную сумму, а Update гарантирует актуальность, пересчитывая путь к корню.

Последний блок — Program.Main. Его задача — просто запустить решение: вызвать SumSegmentTree.Solve(). Он нужен как точка входа приложения C#: именно отсюда начинается выполнение. Он взаимодействует со всем остальным так: Main ничего не знает про ввод, команды и дерево; он только передаёт управление в Solve, а Solve уже организует весь процесс.

Итоговое резюме. Программа читает массив и затем обрабатывает команды двух типов: заменить элемент по индексу и вывести сумму на диапазоне [l, r). Для этого она строит дерево отрезков, хранящее суммы отрезков в виде массива tree, где листья — элементы массива, а внутренние узлы — суммы детей. Обновление меняет один лист и пересчитывает суммы по пути к корню. Запрос суммы превращает границы в индексы листьев и собирает ответ, добавляя готовые суммы тех узлов, которые точно покрывают части нужного диапазона.
