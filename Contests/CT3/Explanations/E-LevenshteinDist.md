# Расстояние по Левенштейну

Этот код реализует вычисление расстояния Левенштейна — классической задачи динамического программирования. Расстояние Левенштейна показывает, какое минимальное количество элементарных операций нужно, чтобы превратить одну строку в другую. Разрешённые операции — вставка символа, удаление символа и замена одного символа на другой. Перед разбором реализации важно понять саму идею алгоритма: мы постепенно сравниваем все префиксы первой строки со всеми префиксами второй строки и для каждой такой пары храним минимальную «стоимость» преобразования.

Класс Levenshtein отвечает за всю алгоритмическую часть. Он хранит две строки, их длины и двумерный массив dp. Этот массив — ключевая структура динамического программирования. В ячейке dp[i, j] будет храниться минимальное число операций, необходимых для преобразования первых i символов строки s1 в первые j символов строки s2. Таким образом, вся задача сводится к корректному заполнению этой таблицы.

Конструктор класса решает задачу подготовки данных и задания базовых условий. Он принимает две строки, сохраняет их, вычисляет их длины и создаёт таблицу dp размером (n + 1) на (m + 1). Дополнительная строка и столбец нужны для работы с пустыми префиксами. Далее идёт 
инициализация базовых случаев динамического программирования. Значения dp[i, 0] означают, сколько операций нужно, чтобы превратить первые i символов первой строки в пустую строку. Единственный способ сделать это — удалить все символы, поэтому значение равно i. Аналогично dp[0, j] показывает, сколько операций нужно, чтобы из пустой строки получить первые j символов второй строки, а это j вставок. Эти базовые значения являются опорой для дальнейших вычислений и используются при заполнении всей таблицы.

Метод Solve реализует сам алгоритм динамического программирования. Здесь происходит последовательное заполнение таблицы dp по строкам и столбцам, начиная с единичных индексов, потому что нулевая строка и нулевой столбец уже инициализированы. Для каждой пары позиций i и j код сравнивает символы s1[i - 1] и s2[j - 1]. Смещение на единицу связано с тем, что строки индексируются с нуля, а dp — с учётом пустого префикса. Если символы совпадают, стоимость замены равна нулю, так как никакой операции делать не нужно. Если символы различаются, стоимость равна единице, так как требуется замена.

После этого для dp[i, j] выбирается минимальное из трёх возможных вариантов. Первый вариант — удалить символ из первой строки, что соответствует переходу из dp[i - 1, j] с добавлением одной операции. Второй вариант — вставить символ в первую строку, что соответствует dp[i, j - 1] плюс одна операция. Третий вариант — заменить символ или оставить его без изменений, если они совпадают, что соответствует переходу из dp[i - 1, j - 1] с добавлением стоимости замены. Таким образом, каждая ячейка dp опирается только на уже посчитанные соседние значения, что и является сутью динамического программирования в этой задаче.

Когда вся таблица заполнена, метод возвращает значение dp[n, m]. Это расстояние Левенштейна для полных строк s1 и s2, так как n и m соответствуют их длинам.

Класс Program содержит точку входа в программу и отвечает только за ввод и вывод. В методе Main считываются две строки из стандартного ввода, создаётся объект Levenshtein, и вызывается метод Solve. Результат вычислений выводится в консоль. Таким образом, Program связывает пользовательский ввод с алгоритмом, но не участвует в логике вычислений.

Итогово этот код работает так: он строит таблицу динамического программирования, где каждая ячейка хранит минимальное число операций для преобразования одного префикса строки в другой. Таблица заполняется последовательно, опираясь на уже вычисленные значения. В результате в правом нижнем углу таблицы получается расстояние Левенштейна для двух исходных строк. Программа читает строки, запускает этот алгоритм и выводит итоговое число операций.
