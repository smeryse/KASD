# TSP

Этот код реализует решение задачи коммивояжёра (Traveling Salesman Problem, TSP) для полного графа с (n) городами с помощью динамического программирования по битовым маскам. Разберём его по логическим блокам.

Сначала объявляется константа `INF`, которая используется для обозначения «бесконечно большой» стоимости пути — это нужно, чтобы корректно находить минимум, когда путь ещё не был построен. Затем в `Main` происходит чтение входных данных: `n` — количество городов, а затем создаётся матрица `dist` размером `n×n`, где `dist[i,j]` — расстояние от города `i` до города `j`. Циклы читают строки ввода и заполняют матрицу числами. Этот блок нужен для того, чтобы задать исходные данные задачи TSP, и он взаимодействует со следующим блоком, где строится динамическое программирование, через матрицу расстояний.

Далее создаются две таблицы: `dp` и `parent`, размером `2^n × n`. Таблица `dp[mask, i]` будет хранить минимальное расстояние, чтобы пройти по всем городам, отмеченным в `mask`, с последним посещённым городом `i`. Таблица `parent[mask, i]` хранит предыдущий город на оптимальном пути для восстановления маршрута. Затем идёт инициализация: все значения `dp` ставятся в `INF`, а `parent` — в `-1`. Этот блок подготавливает структуру для динамического программирования и восстановления маршрута.

Блок с основным циклом — это реализация алгоритма динамического программирования по битовым маскам для TSP. Идея алгоритма: мы рассматриваем все подмножества городов (`mask`) и для каждого подмножества проверяем, каким городом мы можем завершить путь (`last`). Если путь до `last` существует (`dp[mask, last] < INF`), мы пытаемся расширить путь, добавляя ещё один город `next`, который ещё не включён в `mask`. Новый маска `newMask` включает этот город, а `newDist` — суммарное расстояние пути. Если новый путь короче текущего в `dp[newMask, next]`, мы обновляем `dp` и сохраняем `last` как родителя. Этот блок решает саму задачу поиска кратчайшего гамильтонова цикла и взаимодействует с блоками инициализации и восстановления пути.

Следующий блок — поиск минимального расстояния полного маршрута. После того как `dp` заполнена, мы ищем город `lastCity`, на котором завершается оптимальный маршрут, проверяя все `dp[fullMask, i]`, где `fullMask` — маска всех городов. Это позволяет определить длину кратчайшего пути и точку окончания маршрута.

После этого идёт блок восстановления маршрута: начиная с `lastCity` и `fullMask`, мы идём по таблице `parent`, записывая города в массив `path`. Для правильного порядка пути массив разворачивается в обратном направлении. Здесь взаимодействие идёт напрямую с таблицей `parent`, которая хранит оптимальные переходы, и с массивом `path`, который будет выведен в конце.

В финальном блоке выводятся минимальное расстояние и сам маршрут в нужном порядке.

**Итоговое резюме:** Код решает задачу коммивояжёра с помощью динамического программирования по битовым маскам. Сначала считываются расстояния между городами и создаются таблицы для хранения минимальных расстояний и предков. Основной цикл строит оптимальные пути для всех подмножеств городов, используя предыдущие вычисленные значения. Затем находится минимальное расстояние полного маршрута и восстанавливается последовательность городов. В конце выводится длина пути и сам маршрут.
