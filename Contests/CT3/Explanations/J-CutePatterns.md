# Красивые паттерны

Этот код решает задачу подсчёта количества "красивых" бинарных шаблонов — прямоугольных таблиц, заполненных нулями и единицами, в которых нет одноцветных квадратов размером 2×2. Решение использует динамическое программирование по профилю, но в более простой форме, чем в предыдущей задаче с домино.

## Общая идея алгоритма

Мы строим таблицу строка за строкой сверху вниз. Каждую строку можно представить как битовую маску — число, где каждый бит кодирует значение в соответствующей клетке: ноль или единица. Ключевая идея в том, что при выборе текущей строки нам нужно проверить совместимость только с предыдущей строкой. Если в предыдущей и текущей строках нет пары соседних столбцов с одинаковыми значениями в обеих строках, то запрещённого квадрата 2×2 не образуется.

Динамическое программирование здесь работает следующим образом: для каждой строки и каждой возможной маски предыдущей строки мы подсчитываем количество способов достроить оставшуюся часть таблицы. Перебирая все возможные маски текущей строки и проверяя их на совместимость с предыдущей, мы суммируем количество валидных продолжений.

## Структура класса и инициализация

Класс хранит размеры таблицы и словарь для мемоизации. Размер `n` — это количество строк, `m` — количество столбцов. Словарь `dp` использует в качестве ключа кортеж из номера текущей строки и маски предыдущей строки, а в качестве значения — количество способов заполнить оставшиеся строки. Использование кортежей в C# для ключей словаря удобно, так как они автоматически поддерживают корректное сравнение и хеширование.

## Главная функция Dfs

Функция `Dfs` принимает номер текущей строки и маску предыдущей строки. Для первого вызова маска предыдущей строки равна минус единице, что является специальным значением, обозначающим отсутствие предыдущей строки.

Базовый случай проверяет, достигли ли мы конца таблицы. Если номер строки равен `n`, значит все строки успешно заполнены, и мы нашли один валидный способ, поэтому возвращаем единицу.

Далее проверяется мемоизация. Если текущее состояние уже было вычислено ранее, мы сразу возвращаем сохранённый результат. Это критично для производительности, так как одно и то же состояние может встречаться много раз при разных путях построения таблицы.

Основная логика функции — перебор всех возможных масок для текущей строки. Переменная `limit` вычисляется как два в степени `m`, что даёт количество всех возможных комбинаций нулей и единиц в строке длины `m`. Для каждой маски от нуля до `limit` минус один мы проверяем, является ли она валидной относительно предыдущей строки. Если да — рекурсивно вызываем `Dfs` для следующей строки с текущей маской как предыдущей и добавляем результат к общей сумме.

После завершения перебора результат сохраняется в словарь и возвращается.

## Функция проверки валидности IsValid

Функция `IsValid` проверяет, можно ли разместить строку с маской `cur` после строки с маской `prev` без образования одноцветных квадратов 2×2. Первая проверка обрабатывает специальный случай: если `prev` равен минус единице, это означает, что мы проверяем самую первую строку таблицы, и для неё нет ограничений, поэтому возвращаем истину.

Для остальных случаев мы проходим по всем парам соседних столбцов. Цикл идёт до `m` минус один, так как мы рассматриваем пары столбцов с индексами `i` и `i+1`. Для каждой пары мы извлекаем четыре бита: два из предыдущей строки и два из текущей. Переменные `a` и `b` — это биты в позициях `i` и `i+1` предыдущей строки, `c` и `d` — соответствующие биты текущей строки. Извлечение происходит через побитовый сдвиг вправо и взятие младшего бита операцией `& 1`.

Проверка `a == b && b == c && c == d` определяет, все ли четыре значения одинаковы. Если это так, то образуется запрещённый одноцветный квадрат 2×2, и функция возвращает ложь. Если цикл завершился без нахождения таких квадратов, функция возвращает истину, подтверждая валидность комбинации.

## Оптимизация в точке входа

В функции `Main` после чтения размеров происходит важная оптимизация. Если количество строк меньше количества столбцов, они меняются местами. Это делается потому, что сложность алгоритма экспоненциально зависит от количества столбцов — нам нужно перебирать все возможные маски длины `m`, а их два в степени `m`. Поэтому выгоднее делать динамическое программирование по той стороне, которая короче, чтобы количество масок было меньше. Если исходная таблица имеет размер три на десять, лучше рассматривать её как десять строк по три столбца, чем три строки по десять столбцов, так как восемь возможных масок перебрать гораздо быстрее, чем тысяча двадцать четыре.

После этого создаётся объект решателя, вызывается метод `Solve`, и результат выводится.

## Итоговое резюме

Код подсчитывает количество способов заполнить прямоугольную таблицу нулями и единицами так, чтобы в ней не было одноцветных квадратов 2×2. Алгоритм использует динамическое программирование, строя таблицу строка за строкой и представляя каждую строку как битовую маску. Для каждой пары соседних строк проверяется отсутствие запрещённых квадратов через сравнение битов в соседних столбцах. Мемоизация позволяет избежать повторных вычислений, а предварительная проверка размеров обеспечивает оптимальную производительность за счёт минимизации количества перебираемых масок.