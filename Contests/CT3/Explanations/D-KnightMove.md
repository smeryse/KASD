# Телефон коня)

Этот код решает классическую задачу динамического программирования, известную как «Knight Dialer» или «Телефон коня». Смысл задачи в том, чтобы посчитать количество числовых последовательностей длины n, которые можно набрать на телефонной клавиатуре, если между цифрами разрешены только ходы шахматного коня. Далее код разбирается логическими блоками, начиная с идеи алгоритма и заканчивая взаимодействием частей программы.

В основе решения лежит динамическое программирование. Общая идея здесь такая: если мы знаем, сколькими способами можно попасть на каждую цифру за len − 1 шаг, то можем посчитать количество способов попасть на каждую цифру за len шагов, используя разрешённые ходы коня. Вместо перебора всех возможных последовательностей, которые росли бы экспоненциально, мы храним промежуточные результаты и постепенно наращиваем длину последовательности.

Класс KnightPhone инкапсулирует всю логику решения. Поле n хранит длину набираемого номера. Поле mod задаёт модуль, по которому считается ответ, чтобы значения не выходили за пределы типа long. Поле dp — это двумерный массив динамического программирования, где dp[len, digit] означает количество способов набрать последовательность длины len, оканчивающуюся цифрой digit. Это центральная структура данных, через которую связаны все этапы вычислений.

Массив moves задаёт саму «геометрию» задачи. Он кодирует правила ходов шахматного коня на цифровой клавиатуре. Для каждой цифры здесь перечислены цифры, с которых конь может прийти на неё одним ходом. Например, для цифры 0 указаны 4 и 6, потому что именно с этих позиций конь может попасть на 0. Этот массив используется на каждом шаге динамического программирования и фактически описывает граф переходов между цифрами.

Конструктор KnightPhone принимает n и инициализирует массив dp размером (n + 1) на 10. Индексация по длине начинается с 1, а по цифрам — от 0 до 9. Таким образом, конструктор подготавливает память для хранения всех промежуточных состояний, которые будут вычислены в методе Solve.

Метод Solve содержит сам алгоритм. Сначала задаётся базовый случай динамического программирования. Для последовательностей длины 1 считается, что каждая допустимая стартовая цифра даёт ровно один способ. В этом коде цифры 0 и 8 исключаются из базового случая, поэтому для них dp[1, d] остаётся равным нулю, а для остальных цифр устанавливается значение 1. Этот шаг задаёт начальные состояния, от которых дальше будет строиться всё решение.

После инициализации базы запускается основной цикл по длине последовательности от 2 до n. Для каждой длины и для каждой цифры d считается количество способов попасть в эту цифру. Это делается через перебор всех возможных предыдущих цифр prev, из которых конь может прийти на d. Для каждой такой prev берётся значение dp[len − 1, prev] и добавляется к dp[len, d]. Таким образом, dp[len, d] аккумулирует все способы прийти на d за len шагов, опираясь на уже посчитанные значения меньшей длины. Здесь хорошо видно взаимодействие между массивом moves и таблицей dp: moves определяет допустимые переходы, а dp хранит накопленные количества способов.

После заполнения всей таблицы динамического программирования считается итоговый ответ. Для этого суммируются значения dp[n, d] по всем цифрам от 0 до 9, поскольку последовательность длины n может заканчиваться на любой цифре. Результат выводится на экран.

Класс Program содержит только точку входа. В методе Main считывается число n, создаётся объект KnightPhone с этим значением и вызывается метод Solve. Таким образом, Program отвечает только за ввод-вывод, а вся алгоритмическая логика сосредоточена внутри KnightPhone.

В итоге весь код работает так: он моделирует возможные ходы шахматного коня на телефонной клавиатуре как граф, затем с помощью динамического программирования шаг за шагом считает количество допустимых числовых последовательностей заданной длины и выводит суммарный результат. База задаёт стартовые цифры, переходы описываются массивом moves, а таблица dp связывает всё решение в единый вычислительный процесс.
