# Мультирюкзак

Этот код решает задачу упаковки предметов в рюкзаки минимального количества. Дано множество предметов с известными весами и вместимость рюкзака, нужно распределить все предметы по рюкзакам так, чтобы использовать минимальное количество рюкзаков. Решение использует динамическое программирование по подмножествам с битовыми масками.

## Общая идея алгоритма

Алгоритм основан на представлении каждого подмножества предметов через битовую маску — число, где каждый бит отвечает за наличие соответствующего предмета в подмножестве. Если в позиции `i` стоит единица, значит предмет с индексом `i` включён в подмножество, если ноль — не включён. Для набора из `n` предметов существует два в степени `n` различных подмножеств.

Сначала алгоритм предвычисляет для каждого подмножества два параметра: суммарный вес всех предметов в нём и помещается ли это подмножество в один рюкзак. Затем применяется динамическое программирование, где для каждого подмножества предметов вычисляется минимальное количество рюкзаков, необходимых для его упаковки. При этом мы перебираем все возможные способы выделить из текущего подмножества группу предметов для последнего рюкзака, а оставшиеся предметы должны быть уже оптимально упакованы ранее.

## Чтение входных данных

Программа начинается с чтения количества предметов `n` и вместимости рюкзака `s`. Затем читаются веса всех предметов в массив `w`. Вычисляется переменная `N` равная два в степени `n` — это общее количество возможных подмножеств, включая пустое.

## Предвычисление сумм весов

Массив `sum` хранит для каждой маски суммарный вес соответствующего подмножества предметов. Вычисление происходит эффективно через динамическое программирование на подмножествах. Для каждой маски находится её младший установленный бит с помощью трюка `mask & -mask`. Это битовое выражение выделяет только самый правый бит, равный единице, обнуляя все остальные.

Функция `BitIndex` определяет позицию этого бита, то есть индекс предмета. Затем используется формула: сумма для текущей маски равна сумме для маски без этого бита плюс вес найденного предмета. Операция `mask ^ b` обнуляет младший бит в маске, давая подмножество без соответствующего предмета. Такой подход позволяет вычислить все суммы за линейное время относительно количества масок, избегая повторного суммирования.

## Проверка вместимости в рюкзак

Массив `good` отмечает для каждого подмножества, помещается ли оно целиком в один рюкзак. Проверка простая: если суммарный вес подмножества не превышает вместимость `s`, то подмножество помещается. Эта информация понадобится при динамическом программировании для проверки валидности разбиений.

## Динамическое программирование для поиска минимума рюкзаков

Массив `dp` хранит для каждой маски минимальное количество рюкзаков, необходимых для упаковки соответствующего подмножества предметов. Изначально все значения устанавливаются в большое число `INF`, кроме нулевой маски, для которой `dp[0]` равен нулю, так как для пустого подмножества не нужно рюкзаков.

Массив `parent` используется для восстановления ответа — он запоминает для каждой маски, какое подмножество было помещено в последний рюкзак при достижении оптимального результата.

Внешний цикл перебирает все маски от единицы до `N` минус один. Для каждой маски запускается внутренний цикл, который перебирает все её подмаски. Перебор подмасок происходит через специальную идиому `sub = (sub - 1) & mask`. Это выражение генерирует все подмножества данного множества в убывающем порядке. Когда от подмаски отнимаем единицу, младшие биты меняются определённым образом, а операция `& mask` гарантирует, что результат остаётся подмножеством исходной маски.

Для каждой подмаски проверяется, помещается ли она в один рюкзак. Если нет — пропускаем. Если да — вычисляем стоимость такого разбиения: берём количество рюкзаков для оставшихся предметов и добавляем один рюкзак для текущей подмаски. Оставшиеся предметы получаются операцией `mask ^ sub`, которая удаляет из маски все предметы, входящие в подмаску. Если получившееся количество рюкзаков меньше текущего оптимума для маски, обновляем `dp[mask]` и запоминаем подмаску в `parent[mask]`.

## Вывод результата и восстановление ответа

После завершения динамического программирования выводится `dp[N - 1]` — минимальное количество рюкзаков для упаковки всех предметов. Маска `N - 1` представляет собой число, состоящее из `n` единиц в двоичной записи, то есть полное множество всех предметов.

Восстановление ответа происходит движением по массиву `parent` от полной маски к пустой. На каждом шаге извлекается подмаска `sub`, которая была помещена в очередной рюкзак. Формируется список предметов, входящих в эту подмаску, путём проверки каждого бита. Если бит в позиции `i` установлен, предмет с индексом `i` добавляется в список, причём индексация предметов для пользователя начинается с единицы, поэтому добавляется `i + 1`.

Выводится количество предметов в рюкзаке и сами номера предметов через пробел. После вывода текущая маска обновляется операцией `cur ^= sub`, которая удаляет из неё все предметы текущего рюкзака, оставляя те предметы, которые должны быть обработаны на следующих итерациях. Процесс продолжается, пока маска не станет нулевой.

## Вспомогательная функция BitIndex

Функция `BitIndex` находит позицию единственного установленного бита в числе. Она последовательно сдвигает число вправо, пока результат не станет равен единице. Количество сдвигов и даёт искомую позицию. Эта функция вызывается только для чисел вида степени двойки, где установлен ровно один бит, поэтому такой простой подход корректен.

## Итоговое резюме

Код решает задачу минимизации количества рюкзаков для упаковки всех предметов с использованием динамического программирования по подмножествам. Алгоритм предвычисляет суммарные веса всех возможных подмножеств и проверяет их вместимость в один рюкзак, затем для каждого подмножества находит оптимальное разбиение на рюкзаки путём перебора всех вариантов выделения последнего рюкзака. Массив родителей позволяет восстановить конкретное распределение предметов по рюкзакам после нахождения оптимума. Благодаря битовым маскам и эффективным операциям над ними алгоритм работает за экспоненциальное время относительно количества предметов, что приемлемо для небольших значений n.