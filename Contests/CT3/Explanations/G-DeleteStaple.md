# Максимальная правильная скобочная подпоследовательность 

Этот код реализует алгоритм динамического программирования для поиска максимальной корректной подстроки из скобок и вывода этой подстроки. Разберём его логически по блокам и алгоритмическим идеям.

Сначала посмотрим на класс `BracketRemover`. Он хранит входную строку `s`, её длину `n` и две матрицы `dp` и `split`. Матрица `dp[l,r]` будет хранить длину максимальной корректной скобочной последовательности в подстроке от индекса `l` до `r`. Матрица `split[l,r]` используется для восстановления решения: она говорит, как получилось оптимальное значение в `dp[l,r]`. Значения `-1` означают, что использована пара скобок `(l,r)`, а любое неотрицательное число `k` — это точка разбиения подстроки на две части.

Конструктор просто инициализирует эти поля. Это нужно для подготовки к динамическому программированию: заранее создаём таблицы нужного размера, чтобы потом последовательно заполнять их.

Метод `Solve` реализует саму логику динамического программирования. Внешний цикл по `len` идёт по длине подстроки от 1 до `n`. Для каждой длины мы проходим все возможные подстроки `[l, r]`. Сначала для каждой подстроки `dp[l,r]` обнуляется и `split[l,r]` ставится в `-2` (сигнал, что решение пока нет).

Далее идёт проверка на возможность взять пару скобок `s[l]` и `s[r]`. Для этого вызывается метод `IsPair`, который проверяет, образуют ли символы правильную пару `()`, `[]` или `{}`. Если пара возможна, берётся длина решения для внутренней подстроки `dp[l+1,r-1]`, и если добавление этой пары увеличивает длину корректной последовательности, обновляем `dp[l,r]` и ставим `split[l,r] = -1`. Это ключевой момент: здесь применяется идея динамического программирования на подстроках, где оптимальное решение для большей подстроки строится на оптимальном решении для меньших.

Следующий блок — цикл по `k` от `l` до `r-1`, который проверяет, не получится ли большая корректная последовательность, если разделить подстроку на две части `[l,k]` и `[k+1,r]`. Это стандартная техника для скобочных и подобных задач: максимальная корректная последовательность в подстроке либо включает внешние скобки, либо делится на две независимые части. Если такая комбинация даёт большее значение, обновляем `dp[l,r]` и запоминаем точку разбиения в `split[l,r]`.

После заполнения таблиц вызывается метод `Build(0,n-1)`, который рекурсивно восстанавливает корректную последовательность скобок из таблиц `dp` и `split`. Если `split[l,r] = -1`, значит, используем внешнюю пару скобок и рекурсивно строим решение для внутренней подстроки. Если `split[l,r] = k >= 0`, значит, подстрока разбивается на две части и мы рекурсивно строим результат для каждой из них. Базовые случаи `l > r`, `l == r` или `dp[l,r] == 0` возвращают пустую строку, что логично: пустая подстрока или отсутствие корректной последовательности не дают символов.

Метод `IsPair` прост: проверяет три возможные пары скобок. Он нужен для основной логики проверки возможности расширить корректную последовательность внешними скобками.

В `Program.Main` мы просто читаем входную строку, создаём объект `BracketRemover` и вызываем `Solve`, что инициирует заполнение таблиц и печать результата.

**Итоговое резюме:** Код ищет максимальную корректную скобочную последовательность в строке, используя динамическое программирование по подстрокам. Таблица `dp` хранит длину оптимальной последовательности для каждой подстроки, а `split` — информацию для восстановления этой последовательности. Основная идея: оптимальное решение для большой подстроки строится на оптимальных решениях для меньших подстрок, учитывая пары внешних скобок и разбиение на части. Метод `Build` рекурсивно восстанавливает результат, и программа выводит его на консоль.
