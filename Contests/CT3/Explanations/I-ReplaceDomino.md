# Замощение доминошками

Этот код решает классическую задачу динамического программирования по профилю — подсчёт количества способов замостить прямоугольную доску костяшками домино размером 1×2. Доска может содержать заблокированные клетки, которые нельзя использовать. Давай разберёмся, как это работает.

## Общая идея алгоритма

Динамическое программирование по профилю — это техника, при которой мы обрабатываем доску столбец за столбцом слева направо. Ключевая идея в том, что нам нужно отслеживать, какие клетки текущего столбца уже заняты костяшками, пришедшими из предыдущего столбца. Эту информацию мы храним в виде битовой маски — числа, где каждый бит отвечает за строку: единица означает, что клетка занята горизонтальной костяшкой из предыдущего столбца, ноль — что клетка свободна.

Когда мы переходим к очередному столбцу, мы уже знаем, какие его клетки заняты, и должны решить, как заполнить оставшиеся свободные клетки. Мы можем ставить вертикальные костяшки внутри текущего столбца или горизонтальные, которые перейдут в следующий столбец. Таким образом формируется новая маска для следующего столбца.

## Структура класса и инициализация

Класс содержит поля для хранения размеров доски, самой доски и словаря мемоизации. Размеры `n` и `m` — это количество строк и столбцов соответственно. Доска представлена как двумерный массив символов, где точка означает свободную клетку, а крестик — заблокированную. Словарь `dp` используется для запоминания уже вычисленных состояний, чтобы не пересчитывать их заново. Ключ словаря — это закодированная пара из номера столбца и битовой маски, значение — количество способов замостить оставшуюся часть доски.

## Главная функция Dfs

Функция `Dfs` принимает номер текущего столбца и маску, описывающую, какие клетки этого столбца уже заняты. Сначала проверяется базовый случай: если мы прошли все столбцы, то есть `col` равен `m`, мы проверяем маску. Если маска нулевая, значит все клетки корректно заполнены и мы нашли один валидный способ замощения, возвращаем единицу. Если маска ненулевая, значит остались незаполненные обязательства, и этот вариант невалиден, возвращаем ноль.

Дальше происходит проверка мемоизации. Мы кодируем текущее состояние в одно длинное число с помощью функции `Encode` и проверяем, не вычисляли ли мы уже результат для этого состояния. Если да — сразу возвращаем сохранённое значение. Если нет — запускаем функцию `Fill`, которая перебирает все варианты заполнения текущего столбца, сохраняем результат в словарь и возвращаем его.

## Функция Fill — перебор вариантов заполнения

Функция `Fill` работает с одним столбцом, перебирая его строку за строкой. Она принимает четыре параметра: номер столбца, номер текущей строки, текущую маску для этого столбца и маску для следующего столбца, которую мы формируем в процессе.

Первая проверка — достигли ли мы конца столбца. Если `row` равен `n`, значит весь столбец обработан, и мы рекурсивно вызываем `Dfs` для следующего столбца, передавая ему сформированную маску `nextMask`.

Вторая проверка — занята ли текущая клетка. Мы проверяем бит в `curMask`, соответствующий текущей строке. Если бит установлен, значит сюда пришла горизонтальная костяшка из предыдущего столбца, и мы просто переходим к следующей строке, не меняя масок.

Третья проверка — заблокирована ли клетка на доске. Если в `board[row][col]` стоит крестик, мы не можем туда ничего поставить и просто переходим к следующей строке.

Если клетка свободна и не занята, мы рассматриваем два варианта. Первый вариант — поставить вертикальную костяшку. Для этого нужно, чтобы следующая строка существовала, не была занята в текущей маске и не была заблокирована на доске. Если условия выполнены, мы рекурсивно вызываем `Fill`, перескакивая через две строки, так как обе клетки теперь заняты вертикальной костяшкой. Важно, что маски при этом не меняются, потому что вертикальная костяшка остаётся внутри текущего столбца.

Второй вариант — поставить горизонтальную костяшку. Для этого должен существовать следующий столбец, и соседняя клетка справа не должна быть заблокирована. В этом случае мы ставим костяшку, которая занимает текущую клетку и клетку справа в следующем столбце. Поэтому мы переходим к следующей строке текущего столбца и добавляем бит в `nextMask`, отмечая, что соответствующая строка следующего столбца теперь занята.

Функция суммирует количество способов от обоих вариантов и возвращает результат.

## Кодирование состояния

Функция `Encode` объединяет номер столбца и маску в одно 64-битное число. Номер столбца сдвигается на 32 бита влево и объединяется побитовым ИЛИ с маской. Это позволяет использовать пару чисел как уникальный ключ в словаре, избегая создания сложных составных ключей.

## Точка входа программы

В функции `Main` считываются размеры доски, затем построчно считывается сама доска в виде массива символьных массивов. Создаётся объект класса `DominoTiling`, вызывается метод `Solve`, и результат выводится на экран.

## Итоговое резюме

Код использует динамическое программирование по профилю для подсчёта способов замостить доску с препятствиями костяшками домино. Алгоритм обрабатывает доску столбец за столбцом, отслеживая через битовую маску, какие клетки заняты горизонтальными костяшками из предыдущего столбца. Для каждой свободной клетки рекурсивно перебираются два варианта: поставить вертикальную костяшку внутри столбца или горизонтальную в следующий столбец. Мемоизация через словарь позволяет избежать повторных вычислений одинаковых состояний. В результате вычисляется общее количество корректных способов полностью замостить доску.